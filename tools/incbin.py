import os
import sys

HELP_MESSAGE = (
"""incbin.py by Eievui

Converts a binary file into a C array, producing a source and header file at the
given output location.

Usage:
incbin.py -o <output directory> -i <input file>

Flags:
-h, --help:	Print this message.
-i, --input:	The path to the input binary file.
-o, --output:	The path to the output directory.
-p, --prefix:	Optional prefix of the output array.
-n, --name:	Optional name of the output array.
-s, --silence:	Silence success messages.
-a, --autobank:	Autobank the output source file.
-b, --bank:	Force the bank of the output source file.
""")

C_MESSAGE = (
"""/**
 * Generated by incbin.py.
 * Do not include this file directly. Instead, include the header (.h) file of
 * of the same name.
*/\n
""")

H_MESSAGE = (
"""/**
 * Generated by incbin.py.
 * Include this file to access your binary data as an unsigned char array.
*/

#pragma once
""")

def main():

	input_dir = False
	output_dir = False
	out_name = False
	out_pre = ""
	silence_success = False
	bank = 0

	# Parsing
	for i in range(sys.argv.__len__()):
		# I would use a match statement here, but they're relatively new to python
		if sys.argv[i] == "-h" or sys.argv[i] == "--help":
			print(HELP_MESSAGE)
			return
		elif sys.argv[i] == "-i" or sys.argv[i] == "--input":
			input_dir = sys.argv[i + 1] # bytearray(open(sys.argv[i + 1], 'rb').read())
		elif sys.argv[i] == "-o" or sys.argv[i] == "--output":
			output_dir = sys.argv[i + 1]
		elif sys.argv[i] == "-n" or sys.argv[i] == "--name":
			out_name = sys.argv[i + 1]
		elif sys.argv[i] == "-p" or sys.argv[i] == "--prefix":
			out_pre = sys.argv[i + 1]
		elif sys.argv[i] == "-s" or sys.argv[i] == "--silence":
			silence_success = True
		elif sys.argv[i] == "-a" or sys.argv[i] == "--autobank":
			bank = 255
		elif sys.argv[i] == "-b" or sys.argv[i] == "--bank":
			bank = sys.argv[i + 1]
	
	output_c = False
	output_h = False
	
	if not input_dir:
		print("ERROR: Input file required. Use -h for help.")
		return
	
	os.makedirs(output_dir[: output_dir.rfind("/")], 0o777, True)

	if output_dir.find(".h") != -1:
		output_h = open(output_dir, 'w+')
		output_c = open(output_dir[: output_dir.find(".h")] + ".c", 'w+')
	elif output_dir.find(".c") != -1:
		output_c = open(output_dir, 'w+')
		output_h = open(output_dir[: output_dir.find(".c")] + ".h", 'w+')
	else:
		print("ERROR: Output directory required. Use -h for help.")
		return
	
	# Init
	input_array = bytearray(open(input_dir, 'rb').read())

	if out_name:
		out_name = out_pre + out_name
	else:
		out_name = out_pre + input_dir[input_dir.rfind("/") + 1 : input_dir.rfind(".")]
	
	# .c
	output_c.write(C_MESSAGE)
	if bank:
		output_c.write("\n#pragma bank " + str(bank) + "\nconst void __at(" + str(bank) + ") __bank_" + out_name + ";\n\n")
	output_c.write("const unsigned char " + out_name + "[] = {\n")
	lines = 0
	for i in input_array:
		output_c.write("	" + str(i) + ",")
		lines += 1
		if not (lines % 8):
			output_c.write("\n")
	output_c.write("};")

	# .h
	output_h.write(H_MESSAGE)
	if bank:
		output_h.write("#define bank_" + out_name + " ((unsigned char)&__bank_" + out_name + ")\n\n")
		output_h.write("extern const void __bank_" + out_name + ";")
	output_h.write("\nextern const unsigned char " + out_name + "[];")

	# Success
	if not silence_success:
		print("Successfully created \"" + output_dir + "/" + out_name + ".c\" from \"" + input_dir + "\"")

main()